apply plugin: 'com.android.application'

//定义打包时间
def releaseTime() {
    return new Date().format("yyyy-MM-dd", TimeZone.getTimeZone("UTC"))
}

//使用公共函数
if (isJenkins()) {
    apply plugin: 'com.fucknmb.tinker'
    tinker {
        //一系列的配置项
    }
}

def config = rootProject.ext;

android {
    compileSdkVersion config.compileSdkVersion
    buildToolsVersion config.buildToolsVersion

    useLibrary "org.apache.http.legacy"  //支持httpclient请求

    //属于Flavors的默认配置。所有flavor共享
    defaultConfig {
        //应用包名  注意与Manifest.xml文件中packagenName的区别
        applicationId "com.study.gradle" //默认包名
        testApplicationId 'com.study.gradle.test'
        minSdkVersion config.minSdkVersion
        targetSdkVersion config.targetSdkVersion
        versionCode 1
        versionName "1.0"

//        ndk {
//            // 设置支持的 SO 库构架
//            abiFilters 'armeabi', 'armeabi-v7a', 'arm64-v8a', 'x86', 'x86_64', 'mips', 'mips64'
//        }

        //替换AndroidManifest中的占位符
        manifestPlaceholders = [
                UMENG_CHANNEL_VALUE: "umeng",
                SCHEME             : "bbchexian_default"
        ]
        //自定义BuildConfig字段
        buildConfigField "boolean", "LOG_DEBUG", "true"
    }
    buildTypes {
        debug {
            applicationIdSuffix '.debug' // 设置debug时的包名为com.study.gradle.debug

            //自定义BuildConfig字段
            buildConfigField "boolean", "LOG_DEBUG", "true"
            //替换AndroidManifest中的占位符
            manifestPlaceholders = [SCHEME: "bbchexian_debug"]
            //versionName的后缀
            versionNameSuffix "-debug"
            signingConfig signingConfigs.debug
        }
        release {
            //自定义BuildConfig字段
            buildConfigField "boolean", "LOG_DEBUG", "false"
            //替换AndroidManifest中的占位符
            manifestPlaceholders = [SCHEME: "bbchexian_release"]

            //是否进行混淆
            minifyEnabled true
            /**
             混淆文件的位置
             proguardFiles这部分有两段，前一部分代表系统默认的android程序的混淆文件，该文件已经包含了基本的混淆声明，免去了我们很多事，
             这个文件的目录在 sdk/tools/proguard/proguard-android.txt , 后一部分是我们项目里的自定义的混淆文件,文件名可自定义，默认为proguard-rules.pro
             最终混淆的结果是这两部分文件共同作用的。
             */
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            // 移除无用的resource文件
            shrinkResources true
            //release版本使用的签名
            signingConfig signingConfigs.debug
            //打包的apk名称
//            applicationVariants.all { variant ->
//                variant.outputs.each { output ->
//                    def outputFile = output.outputFile
//                    if (outputFile != null && outputFile.name.endsWith('.apk')) {
//                        // 输出apk名称为app_v1.0_2015-01-15_wandoujia.apk
//                        def fileName = "app_v${defaultConfig.versionName}_${releaseTime()}_${variant.productFlavors[0].name}.apk"
//                        output.outputFile = new File(outputFile.parent, fileName)
//                    }
//                }
//            }
        }
        /**
         * 如果我们想要新增加一个buildType，又想要新的buildType继承之前配置好的参数，就可以用init.with()
         * 同理，init.with()还适用于其它配置
         */
        rtm.initWith(buildTypes.release) // 继承release的配置
        rtm {}
    }

    //-----------------多渠道打包-----------------
    /**
     * 第一步 在AndroidManifest.xml里配置PlaceHolder
     <meta-data
     android:name="UMENG_CHANNEL"
     android:value="${UMENG_CHANNEL_VALUE}" />

     第二步 统一替换AndroidManifest中的占位符
     */
    flavorDimensions "channel"
//    productFlavors {
//        xiaomi {
//            manifestPlaceholders = [UMENG_CHANNEL_VALUE: "xiaomi"]
//        }
//        wandoujia {
//            manifestPlaceholders = [UMENG_CHANNEL_VALUE: "wandoujia"]
//        }
//    }
    //或批量修改
//    productFlavors {
//        xiaomi {}
//        wandoujia {}
//    }
//    productFlavors.all {
//        flavor -> flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name]
//    }

    //-----------------设置开发环境和生产环境-----------------
    /**
     * defaultConfig{}中的属性是所有Flavor共享的，Flavor也可以重写defaultConfig中的属性
     * 在打包app之前，Android插件会合并main中的代码和flavor中的代码。当然，依赖项目也可以提供额外的资源，它们也会被合并。
     * 合并的优先级是这样的：
     * BuildType>Flavor>Main>Dependencies
     * 如果一个资源在main中和在flavor中定义了，那么那个在flavor中的资源有更高的优先级。这样那个在flavor文件夹中的资源将会被打包到apk。而在依赖项目申明的资源总是拥有最低优先级。
     * 一个flavor对应一个sourceSet
     */
    productFlavors {
        dev {
            // dev utilizes minSDKVersion = 21 to allow the Android gradle plugin
            // to pre-dex each module and produce an APK that can be tested on
            // Android Lollipop without time consuming dex merging processes.
            minSdkVersion 21
            applicationId 'com.study.gradle.dev'
            targetSdkVersion 28
            versionCode 10
            versionName '1.0'
            versionNameSuffix 'dev'

            //替换manifest中的占位符
            manifestPlaceholders = [
                    icon: "@mipmap/ic_launcher"
            ]
        }
        // 发布
        prod {
            // The actual minSdkVersion for the application.
            minSdkVersion config.minSdkVersion
            //替换manifest中的占位符
            manifestPlaceholders = [
                    icon: "@mipmap/ic_launcher_prod"
            ]
        }
    }


    //-----------------签名配置-----------------
    signingConfigs {
        //debug配置是as默认的，即使用的debug.keystore
        debug {
            storeFile file(STORE_FILE_PATH) //定义在gradle.properties中的
            storePassword STORE_PASSWORD
            keyAlias KEY_ALIAS
            keyPassword KEY_PASSWORD
        }
        release {
            storeFile file(STORE_FILE_PATH)
            storePassword STORE_PASSWORD
            keyAlias KEY_ALIAS
            keyPassword KEY_PASSWORD
        }
    }
    //-----------------配置资源目录-----------------
    sourceSets {
        main {
            jniLibs.srcDirs = ['libs']
        }
    }

    //-----------------lint检查配置-----------------
    lintOptions {
// true--关闭lint报告的分析进度
        quiet true
// true--错误发生后停止gradle构建
        abortOnError false
// true--只报告error
        ignoreWarnings true
// 如果为 true，则当有错误时会显示文件的全路径或绝对路径 (默认情况下为true)
//      absolutePaths true
// 如果为 true，则检查所有的问题，包括默认不检查问题
        checkAllWarnings true
//true--所有warning当做error
        warningsAsErrors true
// 关闭指定问题检查
        disable 'TypographyFractions', 'TypographyQuotes'
// 打开指定问题检查
        enable 'RtlHardcoded', 'RtlCompat', 'RtlEnabled'
// 仅检查指定问题
        check 'NewApi', 'InlinedApi'
// 如果为true，则在错误报告的输出中不包括源代码行号
        noLines true
// 如果为 true，则对一个错误的问题显示它所在的所有地方，而不会截短列表，等等。
        showAll true
// 重置 lint 配置（使用默认的严重性等设置）。
//        lintConfig file("default-lint.xml")
// 如果为 true，生成一个问题的纯文本报告（默认为false）
//        textReport true
// 配置写入输出结果的位置；它可以是一个文件或 “stdout”（标准输出）
//        textOutput 'stdout'
// 如果为真，会生成一个XML报告，以给Jenkins之类的使用
//        xmlReport false
// 用于写入报告的文件（如果不指定，默认为lint-results.xml）
//        xmlOutput file("lint-report.xml")
// 如果为真，会生成一个HTML报告（包括问题的解释，存在此问题的源码，等等）
//        htmlReport true
// 写入报告的路径，它是可选的（默认为构建目录下的 lint-results.html ）
//        htmlOutput file("lint-report.html")

// 设置为 true， 将使所有release 构建都以issus的严重性级别为fatal（severity=false）的设置来运行lint
// 并且，如果发现了致命（fatal）的问题，将会中止构建（由上面提到的 abortOnError 控制）
        checkReleaseBuilds true
// 设置给定问题的严重级别（severity）为fatal （这意味着他们将会
// 在release构建的期间检查 （即使 lint 要检查的问题没有包含在代码中)
        fatal 'NewApi', 'InlineApi'
// 设置给定问题的严重级别为error
        error 'Wakelock', 'TextViewEdits'
// 设置给定问题的严重级别为warning
        warning 'ResourceAsColor'
// 设置给定问题的严重级别（severity）为ignore （和不检查这个问题一样）
        ignore 'TypographyQuotes'
    }

    //-----------------dexOptions-----------------
    /**
     * 这个配置用于控制我们代码编译打包成dex的细节。
     */
    dexOptions {
        javaMaxHeapSize "4g"  //设置运行 dx 的最大内存
    }

    //-----------------设置java版本-----------------
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

    //-----------------packagingOptions-----------------
    /**
     * packagingOptions常见的设置项有exclude、pickFirst、doNotStrip、merge。
     * 1. exclude，过滤掉某些文件或者目录不添加到APK中，作用于APK，不能过滤aar和jar中的内容。
     * 2. pickFirst，匹配到多个相同文件，只提取第一个，作用于APK，不能过滤aar和jar中的文件。
     * 3. doNotStrip，可以设置某些动态库不被优化压缩。
     * 4. merge，将匹配的文件都添加到APK中，和pickFirst有些相反，会合并所有文件。
     */
    packagingOptions {
        exclude 'LICENSE.txt'
        exclude 'META-INF/DEPENDENCIES'
        exclude 'META-INF/ASL2.0'
        exclude 'META-INF/NOTICE'
        exclude 'META-INF/LICENSE'
        exclude 'META-INF/proguard/androidx-annotations.pro'
    }


}
/**
 * 定义局部变量
 */
ext {
    junitVersion = '4.12'
}

dependencies {
    /**
     * api、implementation的区别(假如A依赖B B依赖C  )
     * api依赖可以传递 则A可以使用C中的代码，当C的代码发生改变，需要重新编译C,B，A
     * implementation会隐藏依赖，则A无法使用C中的代码，目的减少build时间，当C的代码发生改变，只需要重新编译C,B
     */
    //编译libs目录下的所有jar包
    implementation fileTree(include: ['*.jar', '*.aar'], exclude: ['android-support*.jar'], dir: 'libs')
    testImplementation "junit:junit:$junitVersion"

    //通用依赖
    implementation config.supportV4

    //    debugImplementation ""    //debug的依赖
    //    releaseImplementation ""    //release的依赖

    /**
     * 不同Flavor的依赖
     */
    //对于flavor=dev的依赖   选择BuildVariants=devDebug或devRelease 构建下会编译依赖库
//    devImplementation 'com.google.guava:guava:21.0-rc2'
//    devDebugImplementation 'com.google.guava:guava:21.0-rc2' //选择BuildVariants=devDebug下会编译依赖库
//    devReleaseImplementation 'com.google.guava:guava:21.0-rc2' //选择BuildVariants=devRelease下会编译依赖库

    //对于flavor=prod的依赖 选择BuildVariants=devDebug或devRelease 构建下会编译依赖库
//    prodImplementation 'com.hannesdorfmann.smoothprogressbar:library:1.0.0'

    /**
     * module依赖
     * 1、直接依赖源码，优点是修改了代码可以马上生效，缺点是编译速度慢。
     * 2、aar依赖，优点是编译速度快，缺点是修改了代码需要重新生成aar。
     *  开发中，修改代码时就依赖源码，修改完毕后，依赖aar，然后重新build。
     *  编译完成后，在app/build/intermediates/exploded-aar/ 就可以看见我们引用的aar包内容了
     */
    //1.直接依赖源码
    implementation project(':lib_uikit')
    //2.依赖aar
//    implementation(name: 'lib_uikit', ext: 'aar')

    /**
     * 聚合依赖多个库
     * 有时候一些库是一并依赖的，剔除也是要一并剔除的，这样别的开发者就知道哪些库是有相关性的，在删除的时候也比较方便。
     */
    implementation([
            'com.github.tianzhijiexian:logger:2e5da00f0f',
            'com.jakewharton.timber:timber:4.1.2'
    ])

    /**
     * exclude关键字
     * 剔除某个组织或某个库
     */
    // 1.剔除整个组织的库
    implementation('com.facebook.fresco:animated-webp:1.0') {
        exclude group: 'com.android.support' // 仅仅写组织名称
    }
    //2.剔除某个库
    implementation(config.appCompat) {
        exclude group: 'com.android.support', module: 'support-annotations' // 写全称
        exclude group: 'com.android.support', module: 'support-compat'
        exclude group: 'com.android.support', module: 'support-v4'
        exclude group: 'com.android.support', module: 'support-vector-drawable'
    }

    /**
     * compileOnly: 仅在编译的时候需要，但是在运行时不需要依赖
     */
    compileOnly 'javax.annotation:jsr250-api:1.0'

    /**
     * 复用函数
     */
    if (usePercent()) {
        implementation config.recyclerView
    }

}
repositories {
    flatDir {
        dirs 'libs' //this way we can find the .aar file in libs folder
    }
}
